"""
Sales Presentation Reporter

Creates sales-focused reports optimized for prospect demonstrations,
ROI presentations, and competitive positioning materials.
"""

import json
from datetime import datetime
from typing import Any, Dict, List, Optional

from analyzer.ast_engine.core_analyzer import AnalysisResult, Violation


class SalesReporter:
    """Sales presentation and demo reporter."""
    
    def __init__(self):
        self._config = {}
    
    def configure(self, config: Dict[str, Any]) -> None:
        """Configure sales reporter."""
        self._config.update(config)
    
    def generate(self, result: AnalysisResult) -> str:
        """Generate sales presentation content."""
        if self._config.get('demo_mode'):
            return self._generate_demo_content(result)
        else:
            return self._generate_sales_presentation(result)
    
    def _generate_demo_content(self, result: AnalysisResult) -> str:
        """Generate live demo content."""
        violations = result.violations
        
        demo_content = f"""# ðŸš€ Live Connascence Analysis Demo

## Executive Summary
**Repository Analyzed**: {self._config.get('company_name', 'Your Codebase')}  
**Analysis Date**: {datetime.now().strftime('%Y-%m-%d')}  
**Files Analyzed**: {result.total_files_analyzed:,}  
**Analysis Duration**: {getattr(result, 'analysis_duration_ms', 0)}ms

## ðŸ’° Immediate Business Value Identified

### Technical Debt Quantification
- **Total Issues Found**: {len(violations):,}
- **Critical Issues**: {sum(1 for v in violations if v.severity.value == "critical")}
- **High-Impact Opportunities**: {sum(1 for v in violations if v.severity.value == "high")}

### ROI Calculation
{self._create_roi_summary(violations)}

## ðŸŽ¯ Demonstration Highlights

### Pattern Detection Capabilities
{self._create_pattern_showcase(violations)}

### Competitive Advantages
{self._create_competitive_positioning(violations, result)}

### Implementation Roadmap
{self._create_implementation_timeline(violations)}

## ðŸ“ˆ Success Metrics & Benchmarks
{self._create_success_metrics(violations, result)}

## ðŸ¤ Next Steps
{self._create_next_steps()}

---
**Generated by Connascence Enterprise Analyzer**  
*Transforming technical debt into competitive advantage*
"""
        return demo_content
    
    def _generate_sales_presentation(self, result: AnalysisResult) -> str:
        """Generate formal sales presentation."""
        return json.dumps({
            "presentation_type": "sales_pitch",
            "company_name": self._config.get('company_name', 'Prospect'),
            "value_proposition": self._create_value_proposition(result),
            "business_case": self._create_business_case(result),
            "competitive_analysis": self._create_competitive_analysis(result),
            "implementation_plan": self._create_implementation_plan(result),
            "pricing_justification": self._create_pricing_justification(result),
            "risk_mitigation": self._create_risk_mitigation(result),
            "success_stories": self._create_success_stories(),
            "call_to_action": self._create_call_to_action(result)
        }, indent=2)
    
    def _create_roi_summary(self, violations: List[Violation]) -> str:
        """Create compelling ROI summary."""
        if not violations:
            return """**ðŸŽ‰ Exceptional Code Quality Validated**
- Your development practices are already delivering ROI
- Quality investment is paying dividends
- Competitive advantage through superior maintainability"""
        
        # Calculate impact
        total_hours = self._estimate_remediation_hours(violations)
        developer_cost = 150  # Enterprise rate
        total_investment = total_hours * developer_cost
        
        # Calculate savings
        monthly_maintenance_savings = len(violations) * 40
        annual_savings = monthly_maintenance_savings * 12
        bug_prevention_value = sum(v.weight * 200 for v in violations if v.severity.value in ["critical", "high"])
        
        payback_months = total_investment / (annual_savings / 12) if annual_savings > 0 else 0
        
        return f"""**ðŸ’° Quantified Business Impact**
- **Investment Required**: ${total_investment:,.0f} ({total_hours:.0f} developer hours)
- **Annual Savings**: ${annual_savings:,.0f} (maintenance cost reduction)  
- **Bug Prevention Value**: ${bug_prevention_value:,.0f} (critical issue mitigation)
- **Payback Period**: {payback_months:.1f} months
- **3-Year ROI**: {((annual_savings * 3 - total_investment) / total_investment * 100):.0f}%

**Bottom Line**: Every dollar invested returns ${'${:.2f}'.format(annual_savings * 3 / total_investment)} over 3 years."""
    
    def _create_pattern_showcase(self, violations: List[Violation]) -> str:
        """Showcase pattern detection capabilities."""
        if not violations:
            return """**ðŸ” Advanced Pattern Detection Demonstrated**
- Clean architecture patterns validated
- Enterprise-grade code quality confirmed  
- Zero false positives prove precision"""
        
        # Group by type for showcase
        by_type = {}
        for v in violations:
            by_type[v.type.value] = by_type.get(v.type.value, 0) + 1
        
        showcase = []
        type_descriptions = {
            "CoM": "Magic Literal Detection - Found {} hardcoded values ready for extraction",
            "CoP": "API Design Analysis - Identified {} functions needing parameter optimization", 
            "CoA": "Code Duplication Detection - Located {} algorithm duplications for refactoring",
            "CoE": "Execution Order Analysis - Discovered {} critical timing dependencies",
            "CoT": "Type Safety Analysis - Found {} type coupling issues"
        }
        
        for type_code, count in sorted(by_type.items(), key=lambda x: x[1], reverse=True)[:3]:
            description = type_descriptions.get(type_code, f"Advanced Pattern - {count} instances detected")
            showcase.append(f"- **{description.format(count)}**")
        
        return "**ðŸŽ¯ Live Pattern Detection Results**\n" + "\n".join(showcase)
    
    def _create_competitive_positioning(self, violations: List[Violation], result: AnalysisResult) -> str:
        """Create competitive positioning content."""
        analysis_speed = f"{getattr(result, 'analysis_duration_ms', 0)}ms"
        files_per_second = result.total_files_analyzed / (getattr(result, 'analysis_duration_ms', 1) / 1000)
        
        return f"""**âš¡ Competitive Advantages Demonstrated**

**Speed & Scale**
- Analyzed {result.total_files_analyzed} files in {analysis_speed}
- Processing rate: {files_per_second:.0f} files/second
- Enterprise-scale performance validated

**Precision & Accuracy**  
- Zero false positive architecture (clean code correctly identified)
- Surgical precision in problem identification
- {len(violations)} actionable issues vs. noise from competitors

**Business Impact Focus**
- ROI calculations built into every analysis
- Technical debt quantified in business terms
- Strategic recommendations, not just technical alerts"""
    
    def _create_implementation_timeline(self, violations: List[Violation]) -> str:
        """Create implementation timeline."""
        critical = sum(1 for v in violations if v.severity.value == "critical")
        high = sum(1 for v in violations if v.severity.value == "high")
        
        if not violations:
            return """**âœ… Zero Implementation Risk**
- Immediate deployment ready
- No technical debt blocking adoption
- Clean integration path validated"""
        
        phases = []
        
        if critical > 0:
            phases.append(f"**Phase 1 (Week 1-2)**: Emergency fixes - {critical} critical issues")
            
        if high > 0:
            phases.append(f"**Phase 2 (Month 1)**: High-impact improvements - {high} priority items")
            
        phases.append("**Phase 3 (Ongoing)**: Systematic debt reduction & prevention")
        phases.append("**Phase 4 (Month 3)**: Quality gates & automation integration")
        
        return "**ðŸ—“ï¸ Implementation Roadmap**\n" + "\n".join(f"- {phase}" for phase in phases)
    
    def _create_success_metrics(self, violations: List[Violation], result: AnalysisResult) -> str:
        """Create success metrics and benchmarks."""
        violation_density = len(violations) / result.total_files_analyzed if result.total_files_analyzed > 0 else 0
        
        # Industry benchmarks
        if violation_density <= 0.5:
            benchmark = "Top 10% (Enterprise Leaders)"
        elif violation_density <= 1.0:
            benchmark = "Top 25% (Above Average)"
        elif violation_density <= 2.0:
            benchmark = "Industry Average (50th Percentile)"
        else:
            benchmark = "Below Average (Opportunity for Significant Improvement)"
        
        return f"""**ðŸ“Š Industry Benchmarking**
- **Your Current Position**: {benchmark}
- **Violation Density**: {violation_density:.2f} per file
- **Improvement Potential**: {self._calculate_improvement_potential(violations)} positions

**Success Metrics to Track**
- Developer velocity improvement: +15-30%
- Bug reduction: 40-60% fewer production issues
- Onboarding time reduction: 25-40% faster new developer ramp-up
- Code review efficiency: 50% faster review cycles"""
    
    def _create_next_steps(self) -> str:
        """Create next steps section."""
        return """**ðŸŽ¯ Immediate Next Steps**

1. **Technical Deep Dive** (This Week)
   - Live analysis of your additional repositories
   - Custom policy configuration for your standards
   - Integration planning with your CI/CD pipeline

2. **Pilot Program** (Next 2 Weeks)  
   - Implement fixes on subset of identified issues
   - Measure velocity impact and time savings
   - Train core development team

3. **Full Deployment** (Month 1)
   - Enterprise license activation
   - Team-wide rollout and training
   - Automated quality gates implementation

**Ready to Get Started?**
- [ ] Schedule technical integration call
- [ ] Set up pilot repository access  
- [ ] Plan team training sessions"""
    
    def _create_value_proposition(self, result: AnalysisResult) -> Dict[str, Any]:
        """Create comprehensive value proposition."""
        violations = result.violations
        
        return {
            "primary_value": "Transform technical debt from liability to competitive advantage",
            "quantified_benefits": {
                "cost_savings": self._calculate_annual_savings(violations),
                "productivity_gains": "15-30% developer velocity improvement",
                "risk_reduction": f"{len(violations)} potential production issues prevented",
                "quality_improvement": self._calculate_quality_improvement(violations, result)
            },
            "unique_differentiators": [
                "Only tool that quantifies technical debt in business terms",
                "Surgical precision - eliminates false positive noise",
                "Enterprise-scale performance with millisecond analysis",
                "Built-in ROI calculations for every recommendation"
            ],
            "success_validation": {
                "immediate_wins": "See results in first week of implementation",
                "measurable_impact": "Track productivity gains via built-in metrics",
                "long_term_value": "Compound ROI through debt prevention"
            }
        }
    
    def _create_business_case(self, result: AnalysisResult) -> Dict[str, Any]:
        """Create detailed business case."""
        violations = result.violations
        remediation_hours = self._estimate_remediation_hours(violations)
        
        return {
            "problem_statement": {
                "current_state": f"{len(violations)} technical debt issues identified",
                "business_impact": f"${remediation_hours * 150:,.0f} in developer time at risk",
                "competitive_risk": "Technical debt compounds at 10-25% annually"
            },
            "solution_benefits": {
                "immediate": "Identify and prioritize highest-impact improvements",
                "short_term": "Reduce maintenance costs and improve velocity", 
                "long_term": "Establish sustainable quality practices"
            },
            "investment_analysis": {
                "implementation_cost": "One-time setup and training investment",
                "annual_license_cost": "Fraction of one developer's salary",
                "roi_timeline": "Positive ROI typically achieved within 2-3 months"
            },
            "risk_mitigation": {
                "technical_risk": "Prevents compound technical debt interest",
                "business_risk": "Protects development velocity and product quality",
                "competitive_risk": "Maintains technology advantage through superior maintainability"
            }
        }
    
    def _create_competitive_analysis(self, result: AnalysisResult) -> Dict[str, Any]:
        """Create competitive analysis."""
        return {
            "vs_sonarqube": {
                "advantage": "Business impact focus vs. technical noise",
                "differentiator": "ROI quantification built-in"
            },
            "vs_codeclimate": {
                "advantage": "Connascence theory vs. generic metrics", 
                "differentiator": "Surgical precision eliminates false positives"
            },
            "vs_manual_reviews": {
                "advantage": "Consistent, scalable analysis vs. subjective reviews",
                "differentiator": "Enterprise-scale performance with complete coverage"
            },
            "unique_positioning": "Only solution that transforms technical debt analysis into business value quantification"
        }
    
    def _create_implementation_plan(self, result: AnalysisResult) -> Dict[str, Any]:
        """Create implementation plan."""
        violations = result.violations
        
        return {
            "phase_1": {
                "timeline": "Week 1-2",
                "focus": "Critical issue resolution",
                "deliverables": f"{sum(1 for v in violations if v.severity.value == 'critical')} critical fixes",
                "success_criteria": "Zero critical violations remaining"
            },
            "phase_2": {
                "timeline": "Month 1", 
                "focus": "High-impact optimizations",
                "deliverables": f"{sum(1 for v in violations if v.severity.value == 'high')} priority improvements",
                "success_criteria": "Measurable velocity improvement"
            },
            "phase_3": {
                "timeline": "Ongoing",
                "focus": "Systematic debt reduction",
                "deliverables": "Automated quality gates and monitoring",
                "success_criteria": "Sustainable quality practices established"
            }
        }
    
    def _create_pricing_justification(self, result: AnalysisResult) -> Dict[str, Any]:
        """Create pricing justification."""
        violations = result.violations
        annual_savings = self._calculate_annual_savings(violations)
        
        return {
            "cost_benefit_ratio": f"Every $1 invested returns ${annual_savings / 50000:.1f} annually",
            "alternative_costs": {
                "hiring_senior_developer": "$150,000+ annually",
                "code_quality_consultant": "$2,000-5,000 per week",
                "technical_debt_refactoring": f"${self._estimate_remediation_hours(violations) * 150:,.0f} one-time"
            },
            "value_delivered": {
                "immediate": "Instant visibility into technical debt",
                "ongoing": "Continuous quality monitoring and improvement",
                "strategic": "Long-term maintainability and competitive advantage"
            }
        }
    
    def _create_risk_mitigation(self, result: AnalysisResult) -> Dict[str, Any]:
        """Create risk mitigation analysis."""
        return {
            "implementation_risks": {
                "low": "Minimal disruption to existing workflows",
                "mitigation": "Phased rollout with pilot program approach"
            },
            "adoption_risks": {
                "low": "Intuitive interface with clear business value",
                "mitigation": "Comprehensive training and support included"
            },
            "roi_risks": {
                "minimal": "Conservative estimates ensure positive ROI",
                "guarantee": "Measurable results typically seen within 30 days"
            }
        }
    
    def _create_success_stories(self) -> List[Dict[str, Any]]:
        """Create success story examples."""
        return [
            {
                "company": "Enterprise SaaS Provider",
                "challenge": "3000+ technical debt issues slowing releases",
                "solution": "Systematic connascence analysis and remediation",
                "results": "40% faster release cycles, 60% fewer production bugs"
            },
            {
                "company": "Financial Services Platform",
                "challenge": "Complex codebase hindering developer productivity", 
                "solution": "Automated quality gates with connascence monitoring",
                "results": "25% reduction in developer onboarding time"
            }
        ]
    
    def _create_call_to_action(self, result: AnalysisResult) -> Dict[str, Any]:
        """Create compelling call to action."""
        return {
            "primary_cta": "Schedule Your Technical Deep Dive",
            "value_preview": f"Analyze your additional repositories and quantify complete ROI potential",
            "urgency": "Technical debt compounds daily - early action maximizes savings",
            "next_steps": [
                "30-minute technical integration planning call",
                "Live analysis of your core repositories", 
                "Custom ROI calculation for your specific codebase",
                "Pilot program setup with measurable success criteria"
            ],
            "commitment": "See measurable productivity improvements within 30 days or full refund"
        }
    
    # Helper methods
    def _estimate_remediation_hours(self, violations: List[Violation]) -> float:
        """Estimate total remediation hours."""
        hours_by_severity = {"critical": 8, "high": 4, "medium": 2, "low": 1}
        return sum(hours_by_severity.get(v.severity.value, 2) for v in violations)
    
    def _calculate_annual_savings(self, violations: List[Violation]) -> float:
        """Calculate annual savings from remediation."""
        monthly_maintenance = len(violations) * 40  # $40 per violation per month
        bug_prevention = sum(v.weight * 200 for v in violations if v.severity.value in ["critical", "high"])
        return monthly_maintenance * 12 + bug_prevention
    
    def _calculate_quality_improvement(self, violations: List[Violation], result: AnalysisResult) -> str:
        """Calculate quality improvement percentage."""
        if not violations:
            return "Maintains top-tier quality (95%+ health score)"
        
        current_score = max(0, 100 - (len(violations) / result.total_files_analyzed * 20))
        potential_score = min(100, current_score + 30)  # Conservative improvement
        improvement = potential_score - current_score
        
        return f"{improvement:.0f}% quality improvement potential"
    
    def _calculate_improvement_potential(self, violations: List[Violation]) -> str:
        """Calculate competitive position improvement potential."""
        if len(violations) <= 10:
            return "1-2 benchmark"
        elif len(violations) <= 50:
            return "2-3 benchmark" 
        else:
            return "3-4 benchmark"