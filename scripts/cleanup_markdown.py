#!/usr/bin/env python3

# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2024 Connascence Safety Analyzer Contributors
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

"""
Connascence Markdown Cleanup Script
Cross-platform Python solution for cleaning up unnecessary markdown files.

Removes 1,859+ external/demo/system markdown files while preserving 79 core project files.
Consolidates functionality from cleanup_markdown.bat, cleanup_markdown_windows.bat, and cleanup_markdown.sh

Author: Generated by Claude Code
License: MIT
"""

import argparse
import logging
from pathlib import Path
import sys
from typing import Dict, List, Tuple


class MarkdownCleaner:
    """Cross-platform markdown file cleanup utility."""

    def __init__(self, dry_run: bool = False, verbose: bool = False):
        """Initialize the cleanup utility.

        Args:
            dry_run: If True, only show what would be deleted without actually deleting
            verbose: If True, enable detailed logging
        """
        self.dry_run = dry_run
        self.verbose = verbose
        self.setup_logging()

        # Cleanup phases configuration
        self.cleanup_phases = [
            {
                "name": "External Dependencies",
                "path": "vscode-extension/node_modules",
                "expected_files": 806,
                "description": "VSCode extension node_modules markdown files",
            },
            {
                "name": "Demo Repositories",
                "path": "sale/demos",
                "expected_files": 912,
                "description": "Demo repository markdown files",
            },
            {
                "name": "Claude Flow System Files",
                "path": ".claude",
                "expected_files": 141,
                "description": "Claude Flow system markdown files",
            },
            {
                "name": "Duplicate Express Repository",
                "path": "express",
                "expected_files": 12,
                "description": "Duplicate Express repository markdown files",
            },
        ]

        # Additional specific files to clean
        self.specific_files = [".pytest_cache/README.md", "tests/.pytest_cache/README.md"]

        # Files/directories that should be preserved
        self.preserved_files = ["README.md", "CLAUDE.md", "CHANGELOG.md", "docs/", "analysis/", "data-room/"]

    def setup_logging(self):
        """Configure logging based on verbosity level."""
        level = logging.DEBUG if self.verbose else logging.INFO
        logging.basicConfig(level=level, format="%(asctime)s - %(levelname)s - %(message)s", datefmt="%H:%M:%S")
        self.logger = logging.getLogger(__name__)

    def count_markdown_files(self, path: str = ".") -> int:
        """Count all markdown files in the given path.

        Args:
            path: Root path to search for markdown files

        Returns:
            Number of markdown files found
        """
        try:
            # Use pathlib for cross-platform compatibility
            root_path = Path(path)
            md_files = list(root_path.rglob("*.md"))
            return len(md_files)
        except Exception as e:
            self.logger.error(f"Error counting markdown files: {e}")
            return 0

    def find_markdown_files(self, directory: str) -> List[Path]:
        """Find all markdown files in a directory recursively.

        Args:
            directory: Directory to search

        Returns:
            List of Path objects for markdown files
        """
        try:
            dir_path = Path(directory)
            if not dir_path.exists():
                return []
            return list(dir_path.rglob("*.md"))
        except Exception as e:
            self.logger.error(f"Error finding markdown files in {directory}: {e}")
            return []

    def delete_files(self, files: List[Path]) -> Tuple[int, int]:
        """Delete a list of files.

        Args:
            files: List of Path objects to delete

        Returns:
            Tuple of (successful_deletions, failed_deletions)
        """
        successful = 0
        failed = 0

        for file_path in files:
            try:
                if self.dry_run:
                    self.logger.info(f"[DRY RUN] Would delete: {file_path}")
                    successful += 1
                else:
                    file_path.unlink()
                    self.logger.debug(f"Deleted: {file_path}")
                    successful += 1
            except Exception as e:
                self.logger.error(f"Failed to delete {file_path}: {e}")
                failed += 1

        return successful, failed

    def run_cleanup_phase(self, phase: Dict) -> Tuple[int, int]:
        """Execute a single cleanup phase.

        Args:
            phase: Phase configuration dictionary

        Returns:
            Tuple of (files_deleted, files_failed)
        """
        phase_name = phase["name"]
        phase_path = phase["path"]
        expected_files = phase["expected_files"]
        description = phase["description"]

        self.logger.info(f"\n=== Phase: {phase_name} ({expected_files} files) ===")

        if not Path(phase_path).exists():
            self.logger.info(f"Phase skipped: {phase_path} not found")
            return 0, 0

        self.logger.info(f"Removing {description}...")
        md_files = self.find_markdown_files(phase_path)

        if not md_files:
            self.logger.info(f"No markdown files found in {phase_path}")
            return 0, 0

        self.logger.info(f"Found {len(md_files)} markdown files in {phase_path}")
        deleted, failed = self.delete_files(md_files)

        if deleted > 0:
            self.logger.info(f"Phase complete: {deleted} files removed from {phase_name}")

        return deleted, failed

    def cleanup_specific_files(self) -> Tuple[int, int]:
        """Clean up specific individual files.

        Returns:
            Tuple of (files_deleted, files_failed)
        """
        self.logger.info("\n=== Cleaning up specific files ===")

        files_to_delete = []
        for file_path_str in self.specific_files:
            file_path = Path(file_path_str)
            if file_path.exists():
                files_to_delete.append(file_path)

        if not files_to_delete:
            self.logger.info("No specific files to clean up")
            return 0, 0

        return self.delete_files(files_to_delete)

    def verify_preserved_files(self):
        """Verify that important files were preserved."""
        self.logger.info("\n=== Verifying preserved files ===")

        for item in self.preserved_files:
            path = Path(item)
            if path.exists():
                if path.is_file():
                    self.logger.info(f"‚úÖ {item} preserved")
                elif path.is_dir():
                    self.logger.info(f"‚úÖ {item} directory preserved")
            else:
                self.logger.warning(f"‚ö†Ô∏è  {item} not found (may not exist)")

    def print_summary(self, total_deleted: int, total_failed: int, files_before: int, files_after: int):
        """Print cleanup summary.

        Args:
            total_deleted: Total number of files deleted
            total_failed: Total number of files that failed to delete
            files_before: File count before cleanup
            files_after: File count after cleanup
        """
        self.logger.info("\n" + "=" * 50)
        self.logger.info("CLEANUP SUMMARY")
        self.logger.info("=" * 50)

        if self.dry_run:
            self.logger.info("[DRY RUN MODE - No files were actually deleted]")
            self.logger.info(f"Files that would be deleted: {total_deleted}")
        else:
            self.logger.info(f"Files successfully deleted: {total_deleted}")
            if total_failed > 0:
                self.logger.warning(f"Files failed to delete: {total_failed}")

        self.logger.info(f"Markdown files before cleanup: {files_before}")
        self.logger.info(f"Markdown files after cleanup: {files_after}")
        self.logger.info(
            f"Reduction: {files_before - files_after} files ({((files_before - files_after) / files_before * 100):.1f}%)"
        )

        self.logger.info("\nFiles preserved (should be ~79):")
        self.logger.info("- README.md, CLAUDE.md, CHANGELOG.md (root)")
        self.logger.info("- docs/*.md (5 files - enterprise documentation)")
        self.logger.info("- analysis/self-analysis/*.md (5 files - analysis results)")
        self.logger.info("- data-room/**/*.md (66 files - buyer materials)")

        self.logger.info("\nCategories removed:")
        for phase in self.cleanup_phases:
            self.logger.info(f"- {phase['description']} ({phase['expected_files']} files)")

    def run(self):
        """Execute the complete cleanup process."""
        self.logger.info("Starting Connascence Markdown Cleanup...")
        self.logger.info("=" * 50)

        # Count files before cleanup
        files_before = self.count_markdown_files()
        self.logger.info(f"BEFORE cleanup: {files_before} total markdown files found")

        if self.dry_run:
            self.logger.info("\nüîç DRY RUN MODE - No files will be deleted")

        total_deleted = 0
        total_failed = 0

        # Execute cleanup phases
        for phase in self.cleanup_phases:
            deleted, failed = self.run_cleanup_phase(phase)
            total_deleted += deleted
            total_failed += failed

        # Clean up specific files
        deleted, failed = self.cleanup_specific_files()
        total_deleted += deleted
        total_failed += failed

        # Count files after cleanup
        files_after = self.count_markdown_files()
        self.logger.info(f"\nAFTER cleanup: {files_after} total markdown files remaining")

        # Verify preserved files
        if not self.dry_run:
            self.verify_preserved_files()

        # Print summary
        self.print_summary(total_deleted, total_failed, files_before, files_after)

        if not self.dry_run and total_failed == 0:
            self.logger.info("\nüéâ Cleanup completed successfully!")
        elif total_failed > 0:
            self.logger.warning(f"\n‚ö†Ô∏è  Cleanup completed with {total_failed} errors")
            return 1

        return 0


def main():
    """Main entry point for the cleanup script."""
    parser = argparse.ArgumentParser(
        description="Cross-platform markdown file cleanup utility for Connascence project",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python cleanup_markdown.py                    # Run cleanup
  python cleanup_markdown.py --dry-run          # Preview what would be deleted
  python cleanup_markdown.py --verbose          # Enable detailed logging
  python cleanup_markdown.py --dry-run --verbose # Preview with detailed output
        """,
    )

    parser.add_argument(
        "--dry-run", "-n", action="store_true", help="Show what would be deleted without actually deleting files"
    )

    parser.add_argument("--verbose", "-v", action="store_true", help="Enable verbose logging")

    parser.add_argument("--version", action="version", version="Connascence Markdown Cleanup 1.0.0")

    args = parser.parse_args()

    # Create and run the cleaner
    try:
        cleaner = MarkdownCleaner(dry_run=args.dry_run, verbose=args.verbose)
        return cleaner.run()
    except KeyboardInterrupt:
        print("\n\nCleanup interrupted by user")
        return 130
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
