# Enterprise Workflow: Semgrep + Connascence Integration Examples
# Demonstrates how enterprises can use both tools complementary

# Example 1: Fast CI/CD Pipeline with Deep Analysis Gate
workflow_fast_feedback:
  name: "Fast Feedback Loop"
  description: "Semgrep provides immediate feedback, Connascence provides architectural insights"
  
  stages:
    pre_commit:
      tool: "Semgrep"
      duration: "< 30 seconds"
      coverage: |
        - Magic numbers and hardcoded values (CoM)
        - Parameter ordering issues (CoP) 
        - Basic timing problems (CoT)
        - Simple execution dependencies (CoE)
        - Object identity issues (CoI)
      
      rules_triggered:
        - "magic-numbers-financial"
        - "excessive-parameters-position-coupling"
        - "race-condition-shared-state"
        - "method-call-ordering-dependency"
        - "object-reference-coupling"
      
      feedback: "Immediate blocking of obvious coupling issues"
      
    pull_request:
      tool: "Semgrep + Light Connascence"
      duration: "1-3 minutes" 
      coverage: |
        - All Semgrep rules (pattern-based)
        - Basic connascence metrics
        - Coupling hotspot identification
      
      integration_point: |
        # GitHub Actions workflow snippet
        - name: Fast Static Analysis
          run: |
            semgrep --config=connascence-enterprise --json > semgrep-results.json
            connascence-analyzer --quick-scan --output=coupling-summary.json
            
        - name: Combined Report
          run: |
            merge-analysis-results \
              --semgrep=semgrep-results.json \
              --connascence=coupling-summary.json \
              --output=pr-analysis.md

    nightly_deep_analysis:
      tool: "Full Connascence Analysis"
      duration: "10-60 minutes"
      coverage: |
        - Complete architectural coupling analysis
        - Cross-module dependency mapping  
        - Technical debt quantification
        - Coupling trend analysis
        - Refactoring recommendations
      
      enterprise_value: |
        - Quantified technical debt ($$ impact)
        - Architecture quality metrics
        - Refactoring priority matrix
        - Team velocity correlation

# Example 2: Microservices Architecture Analysis
microservices_analysis:
  name: "Distributed System Coupling Analysis"
  
  service_boundaries:
    semgrep_role: "Inter-service coupling detection"
    patterns:
      - "Hardcoded service URLs (CoM)"
      - "Shared database table references (CoM)"
      - "Cross-service object sharing (CoI)"
      - "Service call ordering dependencies (CoE)"
    
    connascence_role: "Service boundary validation"  
    analysis:
      - "Cross-service connascence strength measurement"
      - "Service dependency graph generation"
      - "Boundary violation quantification"
      - "Microservice decomposition recommendations"

  example_integration:
    configuration: |
      # .semgrepci.yml
      rules:
        - connascence-pack/service-boundaries
        - connascence-pack/inter-service-coupling
        
    custom_rule: |
      # Custom rule for microservice coupling
      - id: cross-service-database-coupling
        message: |
          Direct database access across service boundaries creates CoM coupling.
          Services should communicate via APIs, not shared database access.
          
          Enterprise impact: Breaks service autonomy and deployment independence.
        severity: ERROR
        patterns:
          - pattern: |
              // Service A accessing Service B's tables
              SELECT * FROM user_service.users
          - pattern: |
              const userDb = require('../user-service/database');

# Example 3: Legacy Modernization Strategy  
legacy_modernization:
  name: "Strategic Legacy Code Refactoring"
  
  phase_1_assessment:
    tool: "Semgrep Rapid Assessment"
    purpose: "Identify quick wins and obvious issues"
    timeline: "1-2 weeks"
    deliverables:
      - "Coupling hotspot heatmap"
      - "Critical issue inventory" 
      - "Low-effort/high-impact fixes"
    
  phase_2_deep_dive:
    tool: "Connascence Architectural Analysis"
    purpose: "Understand coupling structure and refactoring strategy"
    timeline: "4-6 weeks"
    deliverables:
      - "Architectural coupling map"
      - "Refactoring priority matrix"
      - "Effort/benefit analysis"
      - "Migration strategy roadmap"

  business_case_metrics:
    current_state: |
      - Bug fix time: 4.2 days average
      - Feature delivery: 6.8 weeks
      - Developer onboarding: 3.2 months
      - Production incidents: 1.7/week
      
    projected_improvement: |
      - Bug fix time: 1.8 days (-57%)
      - Feature delivery: 3.1 weeks (-54%)  
      - Developer onboarding: 1.2 months (-63%)
      - Production incidents: 0.4/week (-76%)

# Example 4: Enterprise Quality Gates
quality_gates:
  name: "Multi-Layer Quality Assurance"
  
  gate_1_syntax:
    tool: "Semgrep"
    threshold: "Zero ERROR level violations"
    blocking: true
    typical_issues:
      - "Magic numbers in financial calculations"
      - "Hardcoded configuration values"
      - "Race condition patterns"
  
  gate_2_architecture:
    tool: "Connascence Analysis"
    threshold: "Coupling index < 7.5/10"
    blocking: true
    metrics:
      - "Average connascence strength per module"
      - "Cross-module coupling density"
      - "Architectural debt accumulation rate"
  
  gate_3_trends:
    tool: "Combined Trend Analysis" 
    threshold: "No degradation in key metrics"
    blocking: false
    tracking:
      - "Coupling trend over last 6 months"
      - "Technical debt velocity"
      - "Refactoring effectiveness"

# Example 5: Developer Training Integration
developer_education:
  name: "Coupling Awareness Training Program"
  
  learning_path:
    beginner:
      focus: "Semgrep rule understanding"
      duration: "2 hours"
      content: |
        - What is coupling and why it matters
        - Reading Semgrep reports effectively
        - Quick fixes for common coupling issues
        
    intermediate: 
      focus: "Connascence principles"
      duration: "1 day workshop"
      content: |
        - Deep dive into connascence types
        - Architectural impact analysis
        - Refactoring strategies and patterns
        
    advanced:
      focus: "Enterprise architecture design"
      duration: "2 day intensive"
      content: |
        - System-wide coupling optimization  
        - Microservice boundary definition
        - Legacy modernization planning

  hands_on_exercises:
    exercise_1: "Fix Semgrep violations in sample codebase"
    exercise_2: "Reduce connascence strength in legacy module"
    exercise_3: "Design low-coupling API for new feature"

# ROI Calculation Framework
roi_framework:
  cost_factors:
    tooling: "$50K-200K annually (both tools + infrastructure)"
    training: "$25K-100K (team education and onboarding)"
    process_integration: "$75K-300K (CI/CD setup, reporting)"
    
  benefit_factors:
    defect_reduction: "$500K-2M annually (fewer production issues)"
    velocity_improvement: "$300K-1.5M annually (faster feature delivery)"  
    maintenance_savings: "$200K-800K annually (easier refactoring)"
    onboarding_acceleration: "$100K-500K annually (faster team scaling)"
    
  payback_period: "3-8 months for most enterprise teams"
  
  success_metrics:
    technical:
      - "Coupling index improvement: >30% in 6 months"
      - "Critical coupling violations: <5 per 1000 LOC"
      - "Cross-module dependencies: <20% of total dependencies"
      
    business:
      - "Bug fix time reduction: >40%"
      - "Feature delivery acceleration: >25%"
      - "Developer satisfaction score: >4.2/5.0"