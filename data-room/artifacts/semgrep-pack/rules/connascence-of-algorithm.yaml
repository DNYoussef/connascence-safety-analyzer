rules:
  # Connascence of Algorithm - Duplicate Algorithm Implementation
  - id: duplicate-sorting-algorithm-coa
    pattern-either:
      - pattern: |
          for ($I = 0; $I < $N; $I++) {
            for ($J = 0; $J < $N - 1; $J++) {
              if ($ARR[$J] > $ARR[$J + 1]) {
                $TEMP = $ARR[$J];
                $ARR[$J] = $ARR[$J + 1];
                $ARR[$J + 1] = $TEMP;
              }
            }
          }
      - pattern: |
          for i in range($N):
              for j in range(0, $N - i - 1):
                  if $ARR[j] > $ARR[j + 1]:
                      $ARR[j], $ARR[j + 1] = $ARR[j + 1], $ARR[j]
      - pattern: |
          for (int $I = 0; $I < $N; $I++) {
              for (int $J = 0; $J < $N - 1 - $I; $J++) {
                  if ($ARR[$J] > $ARR[$J + 1]) {
                      $TYPE temp = $ARR[$J];
                      $ARR[$J] = $ARR[$J + 1];
                      $ARR[$J + 1] = temp;
                  }
              }
          }
    message: |
      Manual bubble sort implementation creates Connascence of Algorithm (CoA).
      Multiple locations implementing the same sorting logic must stay in sync.
      Use built-in sorting functions instead.
    languages:
      - javascript
      - typescript
      - python
      - java
    severity: WARNING
    metadata:
      category: connascence-of-algorithm
      confidence: HIGH
      impact: HIGH
      likelihood: MEDIUM
      cwe: "CWE-1177: Use of Prohibited Code"
      fix_guidance: |
        Use standard library sorting:
        ```javascript
        // Before - manual bubble sort
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n - 1; j++) {
            if (arr[j] > arr[j + 1]) {
              let temp = arr[j];
              arr[j] = arr[j + 1];
              arr[j + 1] = temp;
            }
          }
        }
        
        // After - built-in sort
        arr.sort((a, b) => a - b);
        ```

  - id: duplicate-validation-algorithm-coa
    pattern-either:
      - pattern: |
          function $FUNC($EMAIL) {
            return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test($EMAIL);
          }
      - pattern: |
          def $FUNC($EMAIL):
              return re.match(r'^[^\s@]+@[^\s@]+\.[^\s@]+$', $EMAIL) is not None
      - pattern: |
          public boolean $FUNC(String $EMAIL) {
              return $EMAIL.matches("^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$");
          }
    message: |
      Duplicate email validation algorithm creates Connascence of Algorithm (CoA).
      Multiple implementations must agree on validation rules.
      Consider centralizing validation logic.
    languages:
      - javascript
      - typescript
      - python
      - java
    severity: WARNING
    metadata:
      category: connascence-of-algorithm
      confidence: HIGH
      impact: MEDIUM
      likelihood: HIGH
      fix_guidance: |
        Centralize validation:
        ```javascript
        // Before - scattered validation
        function validateEmail1(email) {
          return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
        }
        
        // After - centralized
        const EmailValidator = {
          isValid: (email) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
        };
        ```

  - id: duplicate-hashing-algorithm-coa
    pattern-either:
      - pattern: |
          function $FUNC($STR) {
            let hash = 0;
            for (let $I = 0; $I < $STR.length; $I++) {
              const char = $STR.charCodeAt($I);
              hash = ((hash << 5) - hash) + char;
              hash = hash & hash;
            }
            return hash;
          }
      - pattern: |
          def $FUNC($STR):
              hash = 0
              for $I in range(len($STR)):
                  char = ord($STR[$I])
                  hash = ((hash << 5) - hash) + char
                  hash = hash & 0xffffffff
              return hash
    message: |
      Duplicate hash function implementation creates Connascence of Algorithm (CoA).
      Multiple locations implementing the same hash algorithm must produce identical results.
      Consider using a shared utility or library function.
    languages:
      - javascript
      - typescript
      - python
    severity: ERROR
    metadata:
      category: connascence-of-algorithm
      confidence: HIGH
      impact: HIGH
      likelihood: LOW
      fix_guidance: |
        Use shared hashing utility:
        ```javascript
        // Before - duplicate implementations
        function hash1(str) { /* algorithm */ }
        function hash2(str) { /* same algorithm */ }
        
        // After - shared implementation
        const HashUtil = {
          djb2: (str) => { /* single implementation */ }
        };
        ```

  - id: duplicate-encryption-algorithm-coa
    pattern-either:
      - pattern: |
          function encrypt($DATA, $KEY) {
            ...
            for ($I = 0; $I < $DATA.length; $I++) {
              $RESULT += String.fromCharCode($DATA.charCodeAt($I) ^ $KEY.charCodeAt($I % $KEY.length));
            }
            ...
          }
      - pattern: |
          def encrypt($DATA, $KEY):
              ...
              for $I in range(len($DATA)):
                  $RESULT += chr(ord($DATA[$I]) ^ ord($KEY[$I % len($KEY)]))
              ...
    message: |
      Duplicate encryption algorithm implementation creates Connascence of Algorithm (CoA).
      Encryption/decryption pairs must use identical algorithms.
      Use established crypto libraries instead of custom implementations.
    languages:
      - javascript
      - typescript
      - python
    severity: ERROR
    metadata:
      category: connascence-of-algorithm
      confidence: HIGH
      impact: CRITICAL
      likelihood: LOW
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A02:2021 - Cryptographic Failures"
      fix_guidance: |
        Use established crypto libraries:
        ```javascript
        // Before - custom XOR encryption
        function encrypt(data, key) { /* custom algorithm */ }
        
        // After - standard library
        const crypto = require('crypto');
        const algorithm = 'aes-256-gcm';
        function encrypt(data, key) {
          const iv = crypto.randomBytes(16);
          const cipher = crypto.createCipher(algorithm, key, iv);
          return cipher.update(data, 'utf8', 'hex') + cipher.final('hex');
        }
        ```

  - id: duplicate-date-parsing-algorithm-coa
    pattern-either:
      - pattern: |
          function parseDate($DATE_STR) {
            const parts = $DATE_STR.split('/');
            return new Date(parts[2], parts[0] - 1, parts[1]);
          }
      - pattern: |
          def parse_date($DATE_STR):
              parts = $DATE_STR.split('/')
              return datetime(int(parts[2]), int(parts[0]), int(parts[1]))
    message: |
      Duplicate date parsing algorithm creates Connascence of Algorithm (CoA).
      Multiple parsers must agree on date format interpretation.
      Use standardized date parsing libraries.
    languages:
      - javascript
      - typescript
      - python
    severity: WARNING
    metadata:
      category: connascence-of-algorithm
      confidence: HIGH
      impact: MEDIUM
      likelihood: HIGH
      fix_guidance: |
        Use standard date parsing:
        ```javascript
        // Before - custom parsing
        function parseDate(dateStr) {
          const parts = dateStr.split('/');
          return new Date(parts[2], parts[0] - 1, parts[1]);
        }
        
        // After - standard parsing with format specification
        const moment = require('moment');
        function parseDate(dateStr, format = 'MM/DD/YYYY') {
          return moment(dateStr, format).toDate();
        }
        ```

  - id: duplicate-checksum-algorithm-coa
    pattern-either:
      - pattern: |
          function calculateChecksum($DATA) {
            let sum = 0;
            for (let $I = 0; $I < $DATA.length; $I++) {
              sum += $DATA.charCodeAt($I);
            }
            return sum % 256;
          }
      - pattern: |
          def calculate_checksum($DATA):
              sum = 0
              for $I in range(len($DATA)):
                  sum += ord($DATA[$I])
              return sum % 256
    message: |
      Duplicate checksum calculation creates Connascence of Algorithm (CoA).
      All checksum implementations must use identical algorithm.
      Consider using a shared utility function or standard library.
    languages:
      - javascript
      - typescript
      - python
    severity: WARNING
    metadata:
      category: connascence-of-algorithm
      confidence: HIGH
      impact: HIGH
      likelihood: MEDIUM
      fix_guidance: |
        Centralize checksum calculation:
        ```javascript
        // Before - duplicate implementations
        function checksum1(data) { /* algorithm */ }
        function checksum2(data) { /* same algorithm */ }
        
        // After - shared implementation
        const ChecksumUtil = {
          simple: (data) => {
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
              sum += data.charCodeAt(i);
            }
            return sum % 256;
          }
        };
        ```

  - id: duplicate-search-algorithm-coa
    pattern-either:
      - pattern: |
          function binarySearch($ARR, $TARGET) {
            let $LEFT = 0;
            let $RIGHT = $ARR.length - 1;
            while ($LEFT <= $RIGHT) {
              const $MID = Math.floor(($LEFT + $RIGHT) / 2);
              if ($ARR[$MID] === $TARGET) return $MID;
              else if ($ARR[$MID] < $TARGET) $LEFT = $MID + 1;
              else $RIGHT = $MID - 1;
            }
            return -1;
          }
    message: |
      Duplicate binary search implementation creates Connascence of Algorithm (CoA).
      Multiple search functions must implement identical logic.
      Consider creating a shared search utility.
    languages:
      - javascript
      - typescript
    severity: INFO
    metadata:
      category: connascence-of-algorithm
      confidence: HIGH
      impact: MEDIUM
      likelihood: MEDIUM
      fix_guidance: |
        Create shared search utility:
        ```javascript
        // Before - duplicate implementations
        function binarySearch1(arr, target) { /* algorithm */ }
        function binarySearch2(arr, target) { /* same algorithm */ }
        
        // After - shared utility
        const SearchUtil = {
          binary: (arr, target) => { /* single implementation */ }
        };
        ```

  # Algorithm coupling through shared magic numbers/constants
  - id: algorithm-magic-constants-coa
    pattern-either:
      - pattern: |
          $VAR * 31 + $OTHER
      - pattern: |
          ($VAR << 5) - $VAR
      - pattern: |
          $VAR * 0x1f
    message: |
      Magic constants (31, 0x1f) suggest shared hashing algorithms.
      This creates Connascence of Algorithm (CoA) - all implementations must use same constants.
      Extract to named constants or shared utilities.
    languages:
      - javascript
      - typescript
      - java
      - python
    severity: INFO
    metadata:
      category: connascence-of-algorithm
      confidence: MEDIUM
      impact: MEDIUM
      likelihood: HIGH
      fix_guidance: |
        Extract algorithmic constants:
        ```javascript
        // Before - magic numbers scattered
        hash = hash * 31 + char;
        hash = (hash << 5) - hash + char;
        
        // After - named constants
        const HASH_MULTIPLIER = 31;
        hash = hash * HASH_MULTIPLIER + char;
        ```