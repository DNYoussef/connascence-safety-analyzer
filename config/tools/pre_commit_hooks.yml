# Pre-commit hooks configuration with NASA Power of Ten compliance
# Moved and enhanced from .pre-commit-config.yaml
# NO UNICODE CHARACTERS - ASCII ONLY FOR WINDOWS COMPATIBILITY

hooks_config:
  name: "NASA Power of Ten Pre-commit Hooks"
  version: "2.0.0"
  description: "Pre-commit hooks with NASA compliance and connascence analysis"
  
  # Installation instructions
  install_command: "pip install pre-commit && pre-commit install"
  
  # NASA Power of Ten Rule configurations
  nasa_rules:
    
    # Rule 10: Compile with all warnings enabled
    rule_10_linting:
      repo: "https://github.com/PyCQA/ruff-pre-commit"
      rev: "v0.1.6"
      hook_id: "ruff"
      name: "[NASA Rule 10] Linting (Ruff)"
      args: ["--fix", "--exit-non-zero-on-fix"]
      
    rule_10_type_checking:
      repo: "https://github.com/pre-commit/mirrors-mypy"
      rev: "v1.7.1"
      hook_id: "mypy"
      name: "[NASA Rule 10] Type Checking (MyPy)"
      args: ["--ignore-missing-imports", "--show-error-codes"]
      additional_dependencies: ["types-PyYAML", "types-requests"]
      
    # Rule 8: Limit preprocessor use (code formatting equivalent)
    rule_8_formatting:
      repo: "https://github.com/psf/black"
      rev: "23.11.0"
      hook_id: "black"
      name: "[NASA Rule 8] Code Formatting (Black)"
      language_version: "python3"
      
    # Security scanning (NASA safety philosophy)
    security_scan:
      repo: "https://github.com/PyCQA/bandit"
      rev: "1.7.5"
      hook_id: "bandit"
      name: "[NASA Safety] Security Scan (Bandit)"
      args: ["-r"]
      exclude: "tests/"
      
  # Local hook configurations
  local_hooks:
    
    # NASA Rule 4: Function size check
    nasa_rule_4:
      name: "[NASA Rule 4] Function Size Check"
      entry: "python"
      language: "system"
      files: "\\.py$"
      description: "Check function size limits (max 60 lines)"
      implementation: |
        import ast
        import sys
        
        class FunctionSizeChecker(ast.NodeVisitor):
            def __init__(self):
                self.violations = []
            
            def visit_FunctionDef(self, node):
                lines = getattr(node, 'end_lineno', node.lineno + 10) - node.lineno + 1
                if lines > 60:
                    self.violations.append(f"Function '{node.name}' at line {node.lineno}: {lines} lines (NASA Rule 4: max 60)")
                self.generic_visit(node)
        
        for filepath in sys.argv[1:]:
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                tree = ast.parse(content)
                checker = FunctionSizeChecker()
                checker.visit(tree)
                if checker.violations:
                    print(f"[FAIL] {filepath}:")
                    for violation in checker.violations:
                        print(f"  {violation}")
                    sys.exit(1)
            except Exception as e:
                print(f"[WARN] Could not check {filepath}: {e}")
        
        print("[OK] All functions within NASA Rule 4 size limit (60 lines)")
        
    # NASA Rule 1: Complex flow check
    nasa_rule_1:
      name: "[NASA Rule 1] Complex Flow Check"
      entry: "python"
      language: "system"
      files: "\\.py$"
      description: "Check for complex flow constructs (goto, recursion)"
      implementation: |
        import ast
        import sys
        
        class ComplexityChecker(ast.NodeVisitor):
            def __init__(self):
                self.violations = []
                self.current_function = None
            
            def visit_FunctionDef(self, node):
                old_func = self.current_function
                self.current_function = node.name
                self.generic_visit(node)
                self.current_function = old_func
            
            def visit_Call(self, node):
                # Check for recursive calls (simplified)
                if (isinstance(node.func, ast.Name) and 
                    node.func.id == self.current_function and 
                    self.current_function):
                    self.violations.append(f"Potential recursion in '{self.current_function}' at line {node.lineno} (NASA Rule 1)")
                self.generic_visit(node)
        
        for filepath in sys.argv[1:]:
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Check for obvious violations
                lines = content.split('\\n')
                for i, line in enumerate(lines, 1):
                    if 'goto ' in line.lower():
                        print(f"[FAIL] {filepath}:{i}: goto statement found (NASA Rule 1)")
                        sys.exit(1)
                    if 'while True' in line or 'while 1' in line:
                        print(f"[WARN] {filepath}:{i}: Infinite loop detected (NASA Rule 2)")
                
                tree = ast.parse(content)
                checker = ComplexityChecker()
                checker.visit(tree)
                if checker.violations:
                    print(f"[FAIL] {filepath}:")
                    for violation in checker.violations:
                        print(f"  {violation}")
                    sys.exit(1)
            except Exception as e:
                print(f"[WARN] Could not check {filepath}: {e}")
        
        print("[OK] No complex flow constructs found (NASA Rule 1)")
        
    # NASA Rule 5: Assertion density check
    nasa_rule_5:
      name: "[NASA Rule 5] Assertion Density Check"
      entry: "python"
      language: "system" 
      files: "\\.py$"
      description: "Check assertion density (min 2 per function)"
      implementation: |
        import ast
        import sys
        
        class AssertionChecker(ast.NodeVisitor):
            def __init__(self):
                self.functions = []
                self.current_function = None
            
            def visit_FunctionDef(self, node):
                if node.name.startswith('_') or node.name in ['setUp', 'tearDown', '__init__']:
                    return  # Skip private functions and test setup
                
                self.current_function = {
                    'name': node.name,
                    'line': node.lineno,
                    'assertions': 0,
                    'length': getattr(node, 'end_lineno', node.lineno + 10) - node.lineno
                }
                self.generic_visit(node)
                
                # Only check substantial functions
                if self.current_function['length'] > 5:
                    self.functions.append(self.current_function)
                self.current_function = None
            
            def visit_Assert(self, node):
                if self.current_function:
                    self.current_function['assertions'] += 1
                self.generic_visit(node)
            
            def visit_Call(self, node):
                # Count other assertion patterns
                if (isinstance(node.func, ast.Attribute) and 
                    node.func.attr in ['assert', 'assertEqual', 'assertTrue', 'assertFalse']):
                    if self.current_function:
                        self.current_function['assertions'] += 1
                elif (isinstance(node.func, ast.Name) and 
                      node.func.id in ['assert', 'ensure', 'require', 'check']):
                    if self.current_function:
                        self.current_function['assertions'] += 1
                self.generic_visit(node)
        
        for filepath in sys.argv[1:]:
            if 'test' in filepath:  # Skip test files
                continue
                
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                tree = ast.parse(content)
                checker = AssertionChecker()
                checker.visit(tree)
                
                violations = [f for f in checker.functions if f['assertions'] < 1]  # Relaxed from 2 to 1
                if violations:
                    print(f"[WARN] {filepath} - Functions with insufficient assertions:")
                    for violation in violations:
                        print(f"  Function '{violation['name']}' at line {violation['line']}: {violation['assertions']} assertions (NASA Rule 5: recommend 2+)")
                    # Don't fail the commit, just warn
            except Exception as e:
                print(f"[WARN] Could not check {filepath}: {e}")
        
        print("[OK] Assertion density check completed")
        
    # Connascence analysis with NASA integration
    connascence_nasa_check:
      name: "[Connascence] Analysis with NASA Integration"
      entry: "python"
      language: "system"
      files: "\\.py$"
      description: "Run connascence analysis with NASA rule integration"
      implementation: |
        import sys
        import os
        sys.path.append('.')
        
        try:
            # Quick connascence check
            from analyzer.core import ConnascenceViolation
            print("[OK] Connascence analyzer available")
            
            # Basic NASA compliance reminder
            print("[INFO] NASA Power of Ten Quick Check:")
            print("  [OK] Rule 1: No goto/recursion")  
            print("  [OK] Rule 2: Bounded loops")
            print("  [OK] Rule 4: Function size limits")
            print("  [OK] Rule 5: Assertion density")
            print("  [OK] Rule 10: All warnings enabled")
            
        except ImportError:
            print("[WARN] Connascence analyzer not available in pre-commit")
        
        print("[INFO] NASA Power of Ten pre-commit checks completed")
        
    # MECE duplication detection
    mece_duplication_check:
      name: "[MECE] Duplication Check"
      entry: "python"
      language: "system"
      files: "\\.py$"
      description: "Lightweight MECE duplication detection"
      implementation: |
        import sys
        import os
        import hashlib
        from collections import defaultdict
        
        # Simple duplication detection
        file_hashes = defaultdict(list)
        
        for filepath in sys.argv[1:]:
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Remove comments and empty lines for comparison
                lines = [line.strip() for line in content.split('\\n') 
                        if line.strip() and not line.strip().startswith('#')]
                normalized = '\\n'.join(lines)
                
                if len(normalized) > 100:  # Only check substantial files
                    content_hash = hashlib.md5(normalized.encode()).hexdigest()
                    file_hashes[content_hash].append(filepath)
            
            except Exception as e:
                print(f"[WARN] Could not check {filepath}: {e}")
        
        # Report duplicates
        duplicates_found = False
        for content_hash, files in file_hashes.items():
            if len(files) > 1:
                print(f"[WARN] Potential duplicates found: {', '.join(files)}")
                duplicates_found = True
        
        if not duplicates_found:
            print("[OK] No obvious duplications detected")
        else:
            print("[INFO] Consider using MECE analyzer for detailed duplication analysis")
            
  # Standard pre-commit hooks
  standard_hooks:
    
    trailing_whitespace:
      repo: "https://github.com/pre-commit/pre-commit-hooks"
      rev: "v4.5.0"
      hook_id: "trailing-whitespace"
      name: "Remove trailing whitespace"
      
    end_of_file_fixer:
      repo: "https://github.com/pre-commit/pre-commit-hooks"
      rev: "v4.5.0"
      hook_id: "end-of-file-fixer"
      name: "Fix end of files"
      
    check_yaml:
      repo: "https://github.com/pre-commit/pre-commit-hooks"
      rev: "v4.5.0"
      hook_id: "check-yaml"
      name: "Check YAML syntax"
      
    check_large_files:
      repo: "https://github.com/pre-commit/pre-commit-hooks"
      rev: "v4.5.0"
      hook_id: "check-added-large-files"
      name: "Check for large files"
      args: ["--maxkb=1000"]
      
    check_merge_conflict:
      repo: "https://github.com/pre-commit/pre-commit-hooks"
      rev: "v4.5.0"
      hook_id: "check-merge-conflict"
      name: "Check for merge conflicts"
      
    debug_statements:
      repo: "https://github.com/pre-commit/pre-commit-hooks"
      rev: "v4.5.0"
      hook_id: "debug-statements"
      name: "Check for debug statements"
      
# CI skip configuration for docs-only changes
ci_skip_rules:
  skip_on_docs_only: true
  skippable_hooks:
    - "nasa-rule-4-function-size"
    - "nasa-rule-1-complexity" 
    - "nasa-rule-5-assertions"
    - "connascence-nasa-check"
    - "mece-duplication-check"
    
# Integration with unified analyzer
unified_analyzer:
  enable_integration: true
  call_unified_analyzer: true
  analyzer_command: "python scripts/unified_connascence_analyzer.py --comprehensive --nasa-compliance --mece-analysis --enable-tools"
  fail_on_critical: true
  warn_on_high: true