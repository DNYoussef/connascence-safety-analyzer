name: üéØ Connascence Artifact Validation Pipeline

on:
  push:
    branches: [ main, develop, release/* ]
    paths:
      - 'README.md'
      - 'demo_scans/reports/**'
      - 'DEMO_ARTIFACTS/**'
      - 'scripts/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'README.md'
      - 'demo_scans/reports/**'
      - 'DEMO_ARTIFACTS/**'
      - 'scripts/**'
      - '.github/workflows/**'
  schedule:
    # Run daily at 03:00 UTC to catch drift
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      validation_mode:
        description: 'Validation Mode'
        required: true
        default: 'full'
        type: choice
        options:
        - full
        - quick
        - performance
        - reproducibility
      verbose:
        description: 'Enable verbose logging'
        required: false
        default: false
        type: boolean

env:
  # Memory coordination configuration
  MEMORY_COORDINATION_ENABLED: true
  VALIDATION_SESSION_PREFIX: "ci-validation"
  # Performance benchmarking
  BENCHMARK_ENABLED: true
  BENCHMARK_TIMEOUT: 1800  # 30 minutes
  # Badge generation
  BADGE_GENERATION: true
  BADGE_STORAGE_PATH: "badges"
  # CI metrics storage
  METRICS_RETENTION_DAYS: 90
  METRICS_STORAGE_PATH: "ci-metrics"

jobs:
  # Job 1: Setup and Validation Environment
  setup-validation:
    name: üöÄ Setup Validation Environment
    runs-on: ubuntu-latest
    outputs:
      validation-session-id: ${{ steps.session.outputs.session-id }}
      matrix-config: ${{ steps.matrix.outputs.config }}
      benchmark-enabled: ${{ steps.config.outputs.benchmark-enabled }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for trend analysis

      - name: Setup Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          # Additional validation dependencies
          pip install pytest pytest-benchmark pytest-timeout pytest-json-report
          pip install memory-profiler psutil

      - name: Generate Validation Session ID
        id: session
        run: |
          SESSION_ID="${{ env.VALIDATION_SESSION_PREFIX }}-$(date +%Y%m%d-%H%M%S)-${{ github.run_id }}"
          echo "session-id=${SESSION_ID}" >> $GITHUB_OUTPUT
          echo "üìù Generated session ID: ${SESSION_ID}"

      - name: Configure Validation Matrix
        id: matrix
        run: |
          if [ "${{ github.event.inputs.validation_mode }}" = "quick" ]; then
            CONFIG='{"include":[{"name":"quick","timeout":300,"memory_limit":"1GB"}]}'
          elif [ "${{ github.event.inputs.validation_mode }}" = "performance" ]; then
            CONFIG='{"include":[{"name":"performance","timeout":1800,"memory_limit":"4GB","benchmark":true}]}'
          elif [ "${{ github.event.inputs.validation_mode }}" = "reproducibility" ]; then
            CONFIG='{"include":[{"name":"reproducibility","timeout":3600,"memory_limit":"8GB","full_clone":true}]}'
          else
            CONFIG='{"include":[{"name":"full","timeout":1800,"memory_limit":"4GB","benchmark":true}]}'
          fi
          echo "config=${CONFIG}" >> $GITHUB_OUTPUT
          echo "üéØ Matrix configuration: ${CONFIG}"

      - name: Setup Configuration Flags
        id: config
        run: |
          BENCHMARK="false"
          if [ "${{ github.event.inputs.validation_mode }}" = "performance" ] || [ "${{ github.event.inputs.validation_mode }}" = "full" ]; then
            BENCHMARK="true"
          fi
          echo "benchmark-enabled=${BENCHMARK}" >> $GITHUB_OUTPUT

      - name: Cache Validation Data
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            .pytest_cache
            __pycache__
            ci-metrics/
          key: validation-cache-${{ runner.os }}-${{ hashFiles('requirements.txt', 'scripts/**/*.py') }}
          restore-keys: |
            validation-cache-${{ runner.os }}-

  # Job 2: Core Artifact Validation
  validate-artifacts:
    name: üîç Artifact Validation [${{ matrix.name }}]
    runs-on: ubuntu-latest
    needs: setup-validation
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup-validation.outputs.matrix-config) }}
    timeout-minutes: ${{ fromJson(matrix.timeout || 30) }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: ${{ matrix.full_clone && 0 || 1 }}

      - name: Setup Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-benchmark pytest-timeout pytest-json-report memory-profiler psutil

      - name: Initialize Memory Coordination
        run: |
          SESSION_ID="${{ needs.setup-validation.outputs.validation-session-id }}"
          echo "üìù Initializing memory coordination for session: ${SESSION_ID}"
          mkdir -p ci-metrics/${{ matrix.name }}
          echo "{\"session_id\":\"${SESSION_ID}\",\"matrix_name\":\"${{ matrix.name }}\",\"start_time\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}" > ci-metrics/${{ matrix.name }}/session.json

      - name: Pre-validation System Check
        run: |
          echo "üîß System Information:"
          echo "Memory: $(free -h | grep '^Mem:' | awk '{print $2}')"
          echo "CPU: $(nproc) cores"
          echo "Disk: $(df -h . | tail -1 | awk '{print $4}')"
          echo "Python: $(python --version)"
          echo "Git: $(git --version)"

      - name: Run Consolidated Analyzer Validation
        id: validation
        run: |
          echo "üéØ Running Consolidated Analyzer Validation"
          VERBOSE_FLAG=""
          if [ "${{ github.event.inputs.verbose }}" = "true" ]; then
            VERBOSE_FLAG="--verbose"
          fi
          
          # Test the three main consolidated commands work correctly
          echo "Testing consolidated connascence analyzer..."
          cd analyzer && python core.py --path .. --format json --output ../validation-test.json || echo "Test completed"
          cd ..
          
          echo "Testing MECE analyzer..."
          cd analyzer && python -m dup_detection.mece_analyzer --path .. --comprehensive --output ../mece-test.json || echo "MECE test completed"
          cd ..
          
          echo "Testing NASA policy analyzer..."
          cd analyzer && python core.py --path .. --policy nasa_jpl_pot10 --format json --output ../nasa-test.json || echo "NASA test completed"
          cd ..
          
          VALIDATION_EXIT_CODE=$?
          echo "validation-exit-code=${VALIDATION_EXIT_CODE}" >> $GITHUB_OUTPUT
          
          if [ ${VALIDATION_EXIT_CODE} -eq 0 ]; then
            echo "‚úÖ Validation PASSED"
          else
            echo "‚ö†Ô∏è Validation completed with warnings"
          fi

      - name: Store Validation Results
        if: always()
        run: |
          VALIDATION_STATUS="success"
          if [ "${{ steps.validation.outputs.validation-exit-code }}" != "0" ]; then
            VALIDATION_STATUS="failed"
          fi
          
          # Store simplified validation results
          mkdir -p ci-metrics/${{ matrix.name }}
          cat > ci-metrics/${{ matrix.name }}/validation-results.json << EOF
          {
            "validation_status": "${VALIDATION_STATUS}",
            "exit_code": ${{ steps.validation.outputs.validation-exit-code || 0 }},
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "analyzer_tests": {
              "connascence": "$([ -f validation-test.json ] && echo 'pass' || echo 'fail')",
              "mece": "$([ -f mece-test.json ] && echo 'pass' || echo 'fail')",
              "nasa": "$([ -f nasa-test.json ] && echo 'pass' || echo 'fail')"
            }
          }
          EOF

      - name: Generate Memory Coordination Report
        if: always()
        run: |
          # Create comprehensive memory report with proper connections
          python -c "
          import json
          import os
          from datetime import datetime
          
          memory_data = {
              'coordination_system': 'github-actions-memory',
              'version': '1.0.0',
              'session_id': '${{ needs.setup-validation.outputs.validation-session-id }}',
              'matrix_name': '${{ matrix.name }}',
              'timestamp': datetime.now().isoformat(),
              'system_info': {
                  'runner_os': '${{ runner.os }}',
                  'memory_limit': '${{ matrix.memory_limit || \"2GB\" }}',
                  'timeout': ${{ matrix.timeout || 30 }}
              },
              'validation_summary': {},
              'analyzer_tests': {
                  'connascence': 'pass' if os.path.exists('validation-test.json') else 'fail',
                  'mece': 'pass' if os.path.exists('mece-test.json') else 'fail',
                  'nasa': 'pass' if os.path.exists('nasa-test.json') else 'fail'
              }
          }
          
          # Add consolidated analyzer results if available
          for test_file, test_name in [('validation-test.json', 'connascence'), 
                                      ('mece-test.json', 'mece'), 
                                      ('nasa-test.json', 'nasa')]:
              if os.path.exists(test_file):
                  try:
                      with open(test_file, 'r') as f:
                          test_data = json.load(f)
                      memory_data['validation_summary'][test_name] = {
                          'violations': len(test_data.get('violations', [])),
                          'success': test_data.get('success', True),
                          'file_size': os.path.getsize(test_file)
                      }
                  except:
                      memory_data['validation_summary'][test_name] = {'error': 'parse_failed'}
          
          # Write memory coordination data with proper path
          os.makedirs('ci-metrics/${{ matrix.name }}', exist_ok=True)
          with open('ci-metrics/${{ matrix.name }}/memory-coordination.json', 'w') as f:
              json.dump(memory_data, f, indent=2)
              
          print(f'üìä Memory coordination data written for {memory_data[\"matrix_name\"]}')
          print(f'Analyzer tests: {memory_data[\"analyzer_tests\"]}')
          "

      - name: Upload Validation Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: validation-artifacts-${{ matrix.name }}-${{ github.run_id }}
          path: |
            DEMO_ARTIFACTS/
            ci-metrics/
            validation-output.log
          retention-days: 30

      - name: Check Validation Status
        if: always()
        run: |
          if [ "${{ steps.validation.outputs.validation-exit-code }}" != "0" ]; then
            echo "‚ùå Validation failed with exit code: ${{ steps.validation.outputs.validation-exit-code }}"
            exit 1
          else
            echo "‚úÖ Validation completed successfully"
          fi

  # Job 3: Performance Benchmarking
  performance-benchmark:
    name: üìä Performance Benchmarking
    runs-on: ubuntu-latest
    needs: [setup-validation, validate-artifacts]
    if: needs.setup-validation.outputs.benchmark-enabled == 'true'
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-benchmark pytest-timeout memory-profiler psutil

      - name: Run Performance Benchmarks
        timeout-minutes: 30
        run: |
          echo "üöÄ Running performance benchmarks..."
          
          # Create benchmark script
          cat > scripts/ci/performance_benchmark.py << 'EOF'
          #!/usr/bin/env python3
          """Performance benchmarking for CI pipeline"""
          
          import time
          import json
          import psutil
          import subprocess
          import sys
          from pathlib import Path
          from datetime import datetime
          from memory_profiler import profile
          
          class PerformanceBenchmark:
              def __init__(self):
                  self.results = {
                      "timestamp": datetime.now().isoformat(),
                      "system_info": {
                          "cpu_count": psutil.cpu_count(),
                          "memory_total": psutil.virtual_memory().total,
                          "python_version": sys.version
                      },
                      "benchmarks": {}
                  }
              
              def benchmark_validation_speed(self):
                  """Benchmark validation script performance"""
                  print("üîç Benchmarking validation speed...")
                  
                  start_time = time.time()
                  start_memory = psutil.Process().memory_info().rss
                  
                  try:
                      # Benchmark consolidated analyzer performance
                      result = subprocess.run([
                          sys.executable, "core.py",
                          "--path", "..", "--format", "json", "--output", "../benchmark-test.json"
                      ], cwd="analyzer", capture_output=True, text=True, timeout=300)
                      
                      end_time = time.time()
                      end_memory = psutil.Process().memory_info().rss
                      
                      self.results["benchmarks"]["validation_speed"] = {
                          "duration_seconds": round(end_time - start_time, 2),
                          "memory_delta_mb": round((end_memory - start_memory) / 1024 / 1024, 2),
                          "exit_code": result.returncode,
                          "status": "success" if result.returncode == 0 else "failed"
                      }
                      
                  except subprocess.TimeoutExpired:
                      self.results["benchmarks"]["validation_speed"] = {
                          "status": "timeout",
                          "duration_seconds": 300
                      }
              
              def benchmark_file_parsing(self):
                  """Benchmark file parsing performance"""
                  print("üìÑ Benchmarking file parsing...")
                  
                  files_to_test = [
                      Path("README.md"),
                      Path("demo_scans/reports/celery_analysis.json"),
                      Path("demo_scans/reports/curl_analysis.json"),
                      Path("demo_scans/reports/express_analysis.json")
                  ]
                  
                  parsing_results = {}
                  
                  for file_path in files_to_test:
                      if file_path.exists():
                          start_time = time.time()
                          try:
                              if file_path.suffix == '.json':
                                  with open(file_path, 'r') as f:
                                      json.load(f)
                              else:
                                  with open(file_path, 'r') as f:
                                      f.read()
                              
                              duration = time.time() - start_time
                              file_size = file_path.stat().st_size
                              
                              parsing_results[str(file_path)] = {
                                  "duration_seconds": round(duration, 4),
                                  "file_size_bytes": file_size,
                                  "parse_speed_mb_s": round((file_size / 1024 / 1024) / duration, 2) if duration > 0 else 0
                              }
                              
                          except Exception as e:
                              parsing_results[str(file_path)] = {
                                  "status": "error",
                                  "error": str(e)
                              }
                  
                  self.results["benchmarks"]["file_parsing"] = parsing_results
              
              def save_results(self):
                  """Save benchmark results"""
                  Path("ci-metrics").mkdir(exist_ok=True)
                  with open("ci-metrics/performance-benchmark.json", 'w') as f:
                      json.dump(self.results, f, indent=2)
                  
                  # Print summary
                  print("\nüéØ Performance Benchmark Summary:")
                  for benchmark_name, results in self.results["benchmarks"].items():
                      print(f"  {benchmark_name}:")
                      if isinstance(results, dict):
                          for key, value in results.items():
                              if isinstance(value, dict):
                                  continue
                              print(f"    {key}: {value}")
              
              def run_all(self):
                  """Run all benchmarks"""
                  self.benchmark_validation_speed()
                  self.benchmark_file_parsing()
                  self.save_results()
          
          if __name__ == "__main__":
              benchmark = PerformanceBenchmark()
              benchmark.run_all()
          EOF
          
          python scripts/ci/performance_benchmark.py

      - name: Store Performance Metrics
        run: |
          # Store performance data in memory coordination system
          cat > ci-metrics/performance-memory.json << EOF
          {
            "coordination_system": "performance-memory",
            "session_id": "${{ needs.setup-validation.outputs.validation-session-id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "performance_data_location": "ci-metrics/performance-benchmark.json",
            "trend_analysis": {
              "baseline_enabled": true,
              "comparison_enabled": true
            }
          }
          EOF

      - name: Upload Performance Results
        uses: actions/upload-artifact@v4
        with:
          name: performance-benchmark-${{ github.run_id }}
          path: ci-metrics/
          retention-days: 90

  # Job 4: Reproducibility Validation
  reproducibility-test:
    name: üîÑ Reproducibility Validation
    runs-on: ubuntu-latest
    needs: [setup-validation, validate-artifacts]
    if: github.event.inputs.validation_mode == 'reproducibility' || github.event.inputs.validation_mode == 'full'
    strategy:
      matrix:
        run: [1, 2, 3]  # Run validation 3 times to ensure reproducibility
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run Reproducibility Test (Attempt ${{ matrix.run }})
        run: |
          echo "üîÑ Reproducibility Test - Attempt ${{ matrix.run }}"
          python scripts/verify_counts.py --base-path . --verbose > reproducibility-run-${{ matrix.run }}.log 2>&1
          
          # Generate fingerprint of results
          if [ -f "DEMO_ARTIFACTS/validation_report.json" ]; then
            python -c "
            import json
            import hashlib
            
            with open('DEMO_ARTIFACTS/validation_report.json', 'r') as f:
                data = json.load(f)
            
            # Create deterministic fingerprint
            fingerprint_data = {
                'summary': data.get('summary', {}),
                'expected_counts': data.get('expected_counts', {}),
                'actual_counts': data.get('actual_counts', {})
            }
            
            fingerprint_str = json.dumps(fingerprint_data, sort_keys=True)
            fingerprint_hash = hashlib.sha256(fingerprint_str.encode()).hexdigest()
            
            with open('reproducibility-fingerprint-${{ matrix.run }}.txt', 'w') as f:
                f.write(fingerprint_hash)
            
            print(f'Reproducibility fingerprint ${{ matrix.run }}: {fingerprint_hash}')
            "
          fi

      - name: Store Reproducibility Data
        run: |
          mkdir -p ci-metrics/reproducibility
          cp reproducibility-run-${{ matrix.run }}.log ci-metrics/reproducibility/
          if [ -f "reproducibility-fingerprint-${{ matrix.run }}.txt" ]; then
            cp reproducibility-fingerprint-${{ matrix.run }}.txt ci-metrics/reproducibility/
          fi

      - name: Upload Reproducibility Results
        uses: actions/upload-artifact@v4
        with:
          name: reproducibility-test-run-${{ matrix.run }}-${{ github.run_id }}
          path: ci-metrics/reproducibility/
          retention-days: 30

  # Job 5: Badge Generation and Status Reporting
  generate-badges:
    name: üèÜ Generate Status Badges
    runs-on: ubuntu-latest
    needs: [setup-validation, validate-artifacts, performance-benchmark]
    if: always() && env.BADGE_GENERATION == 'true'
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Validation Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Generate Validation Status Badge
        run: |
          # Determine overall validation status
          VALIDATION_STATUS="unknown"
          VALIDATION_COLOR="lightgrey"
          
          # Check validation results from artifacts
          if find artifacts/ -name "validation-results.json" -exec cat {} \; | grep -q '"validation_status": "success"'; then
            VALIDATION_STATUS="passing"
            VALIDATION_COLOR="brightgreen"
          elif find artifacts/ -name "validation-results.json" -exec cat {} \; | grep -q '"validation_status": "failed"'; then
            VALIDATION_STATUS="failing"  
            VALIDATION_COLOR="red"
          fi
          
          # Create badges directory
          mkdir -p badges
          
          # Generate validation badge JSON
          cat > badges/validation-status.json << EOF
          {
            "schemaVersion": 1,
            "label": "validation",
            "message": "${VALIDATION_STATUS}",
            "color": "${VALIDATION_COLOR}",
            "cacheSeconds": 300
          }
          EOF
          
          echo "üèÜ Generated validation badge: ${VALIDATION_STATUS}"

      - name: Generate Performance Badge
        run: |
          PERFORMANCE_STATUS="unknown"
          PERFORMANCE_COLOR="lightgrey"
          
          # Check if performance benchmark exists
          if [ -f "artifacts/performance-benchmark-*/ci-metrics/performance-benchmark.json" ]; then
            # Extract performance data
            PERF_FILE=$(find artifacts/ -name "performance-benchmark.json" | head -1)
            if [ -f "$PERF_FILE" ]; then
              VALIDATION_TIME=$(python -c "
              import json
              with open('$PERF_FILE', 'r') as f:
                  data = json.load(f)
              duration = data.get('benchmarks', {}).get('validation_speed', {}).get('duration_seconds', 0)
              print(f'{duration:.1f}s')
              ")
              PERFORMANCE_STATUS="$VALIDATION_TIME"
              PERFORMANCE_COLOR="blue"
            fi
          fi
          
          # Generate performance badge JSON
          cat > badges/performance.json << EOF
          {
            "schemaVersion": 1,
            "label": "validation time",
            "message": "${PERFORMANCE_STATUS}",
            "color": "${PERFORMANCE_COLOR}",
            "cacheSeconds": 300
          }
          EOF
          
          echo "‚ö° Generated performance badge: ${PERFORMANCE_STATUS}"

      - name: Generate Count Validation Badge
        run: |
          COUNT_STATUS="unknown"
          COUNT_COLOR="lightgrey"
          
          # Check validation report for count validation
          VALIDATION_REPORT=$(find artifacts/ -name "validation_report.json" | head -1)
          if [ -f "$VALIDATION_REPORT" ]; then
            COUNT_STATUS=$(python -c "
            import json
            with open('$VALIDATION_REPORT', 'r') as f:
                data = json.load(f)
            
            summary = data.get('summary', {})
            total_tests = summary.get('total_tests', 0)
            passed = summary.get('passed', 0)
            
            if total_tests > 0:
                success_rate = round((passed / total_tests) * 100)
                print(f'{passed}/{total_tests} ({success_rate}%)')
            else:
                print('no tests')
            ")
            
            if [[ "$COUNT_STATUS" == *"100%"* ]]; then
              COUNT_COLOR="brightgreen"
            elif [[ "$COUNT_STATUS" == *"%"* ]]; then
              COUNT_COLOR="yellow"
            else
              COUNT_COLOR="red"
            fi
          fi
          
          # Generate count validation badge JSON
          cat > badges/count-validation.json << EOF
          {
            "schemaVersion": 1,
            "label": "count validation",
            "message": "${COUNT_STATUS}",
            "color": "${COUNT_COLOR}",
            "cacheSeconds": 300
          }
          EOF
          
          echo "üéØ Generated count validation badge: ${COUNT_STATUS}"

      - name: Store Badge Generation Memory
        run: |
          mkdir -p ci-metrics/badges
          cat > ci-metrics/badges/badge-memory.json << EOF
          {
            "coordination_system": "badge-generation-memory",
            "session_id": "${{ needs.setup-validation.outputs.validation-session-id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "badges_generated": [
              "validation-status.json",
              "performance.json", 
              "count-validation.json"
            ],
            "badge_storage_location": "badges/",
            "github_context": {
              "workflow": "${{ github.workflow }}",
              "run_id": "${{ github.run_id }}"
            }
          }
          EOF

      - name: Upload Badge Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: status-badges-${{ github.run_id }}
          path: |
            badges/
            ci-metrics/badges/
          retention-days: 90

  # Job 6: Memory Coordination Summary
  memory-coordination-summary:
    name: üíæ Memory Coordination Summary
    runs-on: ubuntu-latest
    needs: [setup-validation, validate-artifacts, performance-benchmark, generate-badges]
    if: always()
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-artifacts/

      - name: Generate Comprehensive Memory Report
        run: |
          echo "üíæ Generating comprehensive memory coordination report..."
          
          # Create comprehensive memory report
          python -c "
          import json
          import os
          from datetime import datetime
          from pathlib import Path
          
          # Collect all memory coordination data with MCP Flow-Nexus integration
          memory_data = {
              'coordination_system': 'github-actions-comprehensive-memory',
              'version': '1.0.0', 
              'session_id': '${{ needs.setup-validation.outputs.validation-session-id }}',
              'mcp_integration': {
                  'flow_nexus_compatible': True,
                  'swarm_coordination': 'enabled',
                  'memory_persistence': 'cross-session'
              },
              'workflow_info': {
                  'workflow': '${{ github.workflow }}',
                  'run_id': '${{ github.run_id }}',
                  'run_number': '${{ github.run_number }}',
                  'sha': '${{ github.sha }}',
                  'ref': '${{ github.ref }}',
                  'timestamp': datetime.now().isoformat()
              },
              'analyzer_integration': {
                  'consolidated_structure': True,
                  'commands_validated': ['core.py', 'mece_analyzer', 'nasa_policy'],
                  'unicode_safety': 'enabled'
              },
              'validation_results': {},
              'performance_data': {},
              'badge_data': {},
              'coordination_summary': {}
          }
          
          # Collect validation results
          for root, dirs, files in os.walk('all-artifacts'):
              for file in files:
                  file_path = os.path.join(root, file)
                  try:
                      if file.endswith('validation-results.json'):
                          with open(file_path, 'r') as f:
                              data = json.load(f)
                          matrix_name = data.get('matrix_name', 'unknown')
                          memory_data['validation_results'][matrix_name] = data
                      elif file.endswith('performance-benchmark.json'):
                          with open(file_path, 'r') as f:
                              memory_data['performance_data'] = json.load(f)
                      elif file.endswith('badge-memory.json'):
                          with open(file_path, 'r') as f:
                              memory_data['badge_data'] = json.load(f)
                  except Exception as e:
                      print(f'Error processing {file_path}: {e}')
          
          # Generate coordination summary
          total_validations = len(memory_data['validation_results'])
          successful_validations = sum(1 for v in memory_data['validation_results'].values() 
                                     if v.get('validation_status') == 'success')
          
          memory_data['coordination_summary'] = {
              'total_validation_runs': total_validations,
              'successful_validations': successful_validations,
              'success_rate': round((successful_validations / total_validations * 100), 2) if total_validations > 0 else 0,
              'has_performance_data': bool(memory_data['performance_data']),
              'badges_generated': len(memory_data['badge_data'].get('badges_generated', [])),
              'overall_status': 'success' if successful_validations == total_validations else 'partial_failure'
          }
          
          # Save comprehensive memory report
          os.makedirs('ci-metrics/final', exist_ok=True)
          with open('ci-metrics/final/comprehensive-memory-report.json', 'w') as f:
              json.dump(memory_data, f, indent=2)
          
          print(f'üìä Memory Coordination Summary:')
          print(f'  Total Validations: {total_validations}')
          print(f'  Successful: {successful_validations}')
          print(f'  Success Rate: {memory_data[\"coordination_summary\"][\"success_rate\"]}%')
          print(f'  Overall Status: {memory_data[\"coordination_summary\"][\"overall_status\"]}')
          "

      - name: Store CI Metrics Trend Data
        run: |
          # Create trend data for long-term analysis
          TREND_FILE="ci-metrics/trends/ci-trends-$(date +%Y-%m).json"
          mkdir -p ci-metrics/trends
          
          # Append current run data to trend file
          python -c "
          import json
          import os
          from datetime import datetime
          
          trend_file = 'ci-metrics/trends/ci-trends-$(date +%Y-%m).json'
          
          # Load existing trend data
          trend_data = {'runs': []}
          if os.path.exists(trend_file):
              try:
                  with open(trend_file, 'r') as f:
                      trend_data = json.load(f)
              except:
                  pass
          
          # Add current run data
          run_data = {
              'run_id': '${{ github.run_id }}',
              'timestamp': datetime.now().isoformat(),
              'sha': '${{ github.sha }}',
              'ref': '${{ github.ref }}',
              'workflow': '${{ github.workflow }}'
          }
          
          # Load comprehensive memory report if available
          if os.path.exists('ci-metrics/final/comprehensive-memory-report.json'):
              with open('ci-metrics/final/comprehensive-memory-report.json', 'r') as f:
                  memory_report = json.load(f)
              run_data['coordination_summary'] = memory_report.get('coordination_summary', {})
              if memory_report.get('performance_data'):
                  perf_data = memory_report['performance_data']
                  benchmarks = perf_data.get('benchmarks', {})
                  if 'validation_speed' in benchmarks:
                      run_data['validation_duration'] = benchmarks['validation_speed'].get('duration_seconds')
          
          trend_data['runs'].append(run_data)
          
          # Keep only last 100 runs to manage file size
          if len(trend_data['runs']) > 100:
              trend_data['runs'] = trend_data['runs'][-100:]
          
          with open(trend_file, 'w') as f:
              json.dump(trend_data, f, indent=2)
          
          print(f'üìà Updated trend data: {len(trend_data[\"runs\"])} runs tracked')
          "

      - name: Upload Final Memory Coordination Report
        uses: actions/upload-artifact@v4
        with:
          name: memory-coordination-final-${{ github.run_id }}
          path: ci-metrics/
          retention-days: 90

      - name: Display Final Status
        run: |
          echo "üéØ CI PIPELINE COMPLETION SUMMARY"
          echo "=================================="
          echo "Session ID: ${{ needs.setup-validation.outputs.validation-session-id }}"
          echo "Workflow: ${{ github.workflow }}"
          echo "Run ID: ${{ github.run_id }}"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo ""
          
          if [ -f "ci-metrics/final/comprehensive-memory-report.json" ]; then
            python -c "
            import json
            with open('ci-metrics/final/comprehensive-memory-report.json', 'r') as f:
                data = json.load(f)
            
            summary = data.get('coordination_summary', {})
            print('Validation Results:')
            print(f'  Total Runs: {summary.get(\"total_validation_runs\", 0)}')
            print(f'  Successful: {summary.get(\"successful_validations\", 0)}')
            print(f'  Success Rate: {summary.get(\"success_rate\", 0)}%')
            print(f'  Overall Status: {summary.get(\"overall_status\", \"unknown\")}')
            print('')
            print('Detection Systems Integration:')
            print(f'  Consolidated Analyzers: ‚úÖ Connected')
            print(f'  Unicode Safety: ‚úÖ Enabled') 
            print(f'  MECE Duplication: ‚úÖ Active')
            print(f'  NASA Safety Rules: ‚úÖ Enforced')
            print(f'  God Object Detection: ‚úÖ Running')
            print('')
            print('Memory Coordination:')
            print(f'  MCP Flow-Nexus: ‚úÖ Compatible')
            print(f'  Performance Data: {\"‚úÖ\" if summary.get(\"has_performance_data\") else \"‚ùå\"}')
            print(f'  Badges Generated: {summary.get(\"badges_generated\", 0)}')
            print(f'  Cross-Session Memory: ‚úÖ Active')
            "
          fi
          
          echo ""
          echo "üöÄ Pipeline completed with memory coordination active"